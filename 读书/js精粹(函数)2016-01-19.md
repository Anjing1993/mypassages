在js中函数还是非常强大的，可以说处处充满了函数，关于js函数在[前面](https://github.com/Anjing1993/mypassages/blob/master/%E8%AF%BB%E4%B9%A6/js%E9%AB%98%E7%A8%8B(%E5%87%BD%E6%95%B0)2016-01-16.md)有详细的讲解，再次读js精粹中的函数，就主要挑一些典型的点来理解：
> 函数对象

函数也是对象，所以当我们创建一个函数的时候，它也会拥有一个prototype属性：

    this.prototype =  [constructor:this]
该prototype对象是用来存放继承特征的地方，但是对于函数来说construcotr其实是没有什么用的


- 对于函数内部函数的[this问题](https://github.com/Anjing1993/mypassages/blob/master/js/about-this2016-01-16.md)，算是语言设计上的问题，jquer也是对其做了处理后产出的proxy 
> 参数

我们都知道，在函数被调用时，它的参数实质上是一个类似于数组的arguments对象；通过它，我们可以直接访问参数，但是正因为它类似于数组，所以它缺少很多数组的方法：

    Function.method('detail',function(){
    var args = arguments, that=this;
        return function(){
           return that.apply(null,args.concat(arguments));
       }
    })

detail方法是利用函数与传递给它的参数，相结合产生一个新的函数的思路，通过创建一个保存着原始函数和被套用的参数的闭包来工作。它返回另一个函数，该函数被调用时，会返回原始函数的结果，并传递调用detail时的参数加上当前调用参数的所有参数，然后使用concat去连接两个参数数组，但是结果却是不尽人意的，就因为arguments并不是真正的数组，所以它没有concat。那么怎么办呢？其实不用担心，这是我们给两个arguments数组都引用数组的slice方法，这样就产出了拥有concat方法的常规数组。
> 作用域

不同于其他编程语言，js是没有块级作用域：

      for(var i=0 ; i<5 ; i++){
        console.log('1');
      }
      console.log(i);  //5
在其他语言中，i在for循环结束后就会被销毁，但是在js中，它还会存在于循环外部的执行环境中，故还是可以访问到的。所以我们以后还是要提前声明要使用的变量

而js函数是有作用域的，这就意味着在函数外部无法访问函数内部的变量。

> 函数回调

这个名词大家应该都很熟悉，也很常用，我们的应用中几乎充满了回调函数，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。而回调函数的适用场合如下：


- 资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。
- DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)
- setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现
- 链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现
- setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理

所以，回调函数的好处还是蛮多的~
## 级联 ##
其实也就是链式调用，在这些调用中，一般都返回的是当前的对象，所以调用返回的结果可以被下一次调用所用，这也是我们为什么常常使用链式调用

这本书并没有很详细的讲解函数，是在函数基础上更深了一个层次做了一些综合，也是很需要我们去注意的点。
