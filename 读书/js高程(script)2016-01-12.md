## javascript之script的一点思考 ##


> javascript诞生于1995年，已经驰骋了11年，js本身刚开始时用来做一些简单的输入验证，而我们都知道现在的javascript具备了与浏览器以及其内容等几乎所有方面的交互能力，已经变成了一种功能全面的编程语言，能够处理复杂的计算以及交互；而且React Native 于2015年9月14日起开始支持Android，我们开发者可以真正做到“一次编写，到处运行”了，似乎有了替代native的趋势。近几年，js的发展是非常迅速的，我接触了它一年半了，觉得它很简单，同时又很难！学会使用它是一件很迅速的事，但是想要彻底的掌握它，理解它就另当别论了。

> 很多时候，我都在盲目的奔跑，总是会去回顾，却发现很多东西都在用，但是自己根本就没有搞懂，所以我想停下来，好好地去回顾一下。我觉得不管是什么知识，总是去搞清楚它的原理，并且可以自己去实现，应该会是进阶过程中很关键的一部分。而js的实现是由ECMAScript，DOM,BOM三部分组成的，所以我们必须这三部分都彻底掌握。

----------
- **这一篇就说说`<script>`这个标签，我们都知道向HTML文档中插入js的主要方法就是通过`<script>`标签，且HTML4.01为`<script>`定义了6个属性：**
 1. src:可选。表示要包含的外部文件的地址
 2. async：可选。表示应该立即下载文件，而不影响页面中的其他操作，主要针对外部文件，**html5规范要求异步脚本按照顺序执行，但实质上这种脚本的异步不能确保再按照以前的顺序执行，故最好含有一个延迟脚本就好**
 3. defer：可选。表示文件可以延迟到文档完全被解析和显示后，再执行，主要针对外部文件，**但是这种脚本的延迟不能确保再按照以前的顺序执行**
 4. charset：可选。表示通过src引入文件的字符集
 5. language：已废弃，原来表示编写代码使用的脚本语言
 6. type：可选。可以看成language的替代品，表示编写代码的脚本语言内容的类型，也成为mime类型。一直以来使用的都是text/javascript，如今这属性是可以忽略的，因为默认的就是text/javascript

----------


- **很明显，这个标签的一些属性，以及它的位置直接决定了它的下载与执行，那么它对页面的影响也就随之而出，我们可以使用defer或者async去控制它，但是这样又无法保证所有`<script>`标签的内容会按照以前的顺序执行。如果这些文件互相之间没有任何依赖，那无所谓！假若这些文件中存在互相的依赖，那么很可能就会出错，所以我们使用它的时候一定要注意：** 
 1. 当然也可以动态生成`<script>`,并且去控制它的下载时间，但是脚本的执行顺序依然无法保证
 2. 这个时候，将延迟脚本放在页面底部，依然是最佳的选择；（至于为什么要将脚本放在底部，接下来会详细讲解）
 3. 我还想到了AMD和CommonJs,CMA的方式，后面会详细的比较

----------


> 为什么script要放在页面底部

 &ensp;&ensp; 我想这个问题很多人都被面试官问到过，我一直的理解是因为浏览器解析页面的时候会按照顺序一行一行去解析构建DOM树并渲染，而遇到js文件，浏览器就会停止页面渲染，而是去下载js文件，直到下载完，然后再接着构建DOM树，然后渲染；如果放在页面底部，js文件就不会影响页面的渲染时间，但是就在就在昨天读了一篇文章时发现我的理解有一些问题:
   
&ensp;&ensp; 首先，这里的页面渲染指的是什么？是“首屏包括图片都加载好了”还是“仅仅没有图片的首屏加载好了”亦或“所有页面都完整的加载好了”（这里假如页面都是有图片的），显然，作为前端开发人员我们往往更关心首屏的加载时间，那这里的页面加载时间就指的是“仅仅没有图片的首屏加载好了”；那么问题就变成了“script标签的位置会影响首屏的加载时间莫？”然后我们就得从**浏览器的渲染机制**说起了,就拿chorme来说吧，其实是有以下**五个步骤**：
  
    必须知道的几个概念： 
    
    1、DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。
    
    2、CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。
    
    3、DOM 和 CSSOM 都是以 Bytes → characters → tokens → nodes → object model. 这样的方式生成最终的数据。
1. 浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。
1.  CSS文件下载完成，开始构建CSSOM
1. 所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。
1. Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。
1. Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。

但是前三个步骤是会多次执行的，因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性；后面两个步骤也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用后面两个步骤来更新网页。

当然我们也可以试着扒一段代码通过node跑起来，node作为服务端对脚本做2秒的延迟，看一下它的TimeLine，这样将会更清晰：
![](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/timeline1.png)
![](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/timeline2.jpg)
![](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/timeline3.jpg)



> 我们会发现：


1. 首屏时间和DomContentLoad事件没有必然的先后关系
1. js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。
1. 普通script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。

>那么 script标签的位置会影响首屏时间么？
> 
> 答案是：不影响（如果这里里的首屏指的是页面从白板变成网页画面——也就是第一次Painting），但有可能截断首屏的内容，使其只显示上面一部分。

> 关于这块的详细情况，快[猛戳链接~~~](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=401657042&idx=1&sn=c06773e257b3ae662f8389b32cbbcebc&scene=2&srcid=0115bRdbpWzsFYbPsPAu1JHn&from=timeline&isappinstalled=0#wechat_redirect)

----------
- #### 以前javascipt会全写在一个大的文件里，一次加载就好了，但是随着代码量的增加，我们将它分为很多个文件，因为defer和async所存在的问题，我们选择将延迟脚本放在页面底部，但是如果有很多文件，它们之间的依赖关系很复杂，代码的管理和维护就会变得很难，这时候**模块化加载**就应用而生了：  ####

 1. CommonJs：它是指一种同步加载，必须要模块加载完才可以执行。对于服务端来说，这不是问题，因为所有的模块都放在本地硬盘中，等待的时间就是硬盘的读取时间，node就是遵循的commonjs，主要为js在后端表现制定的；但对于浏览器就不同了，所有模块都放在服务端，等待时间取决于网速，浏览器很可能会处于假死状态：
（1）定义模块：一个单独的文件就是一个模块，每一个模块都是单独的作用域
（2）模块出口：module.exports,我们需要把模块希望输出的内容放入该对象
（3）加载模块：require,该方法读取一个文件并执行，返回文件内部的module.exports对象
 2. AMD：是一种异步模块加载，后一个模块的加载不受前一个模块加载的影响，但是对于有互相依赖的模块，被依赖的文件需早于依赖它的文件加载。RequireJs,CurlJs都遵循了AMD规则，它们是使用define先去定义模块，再用require去加载模块。所以，我们可以使用AMD规则去加载我们所需要的js，即减少了script标签，又实现了我们想要的
 3. CMD：是一种通用的模块加载，不同于AMD的是它推崇依赖就近，需要的时候再去加载

----------
这些模块化的加载都有自己的规范，我们想要使用哪个就要具体去学习它的使用，它还是很好掌握的，其中有一些很好的实现了js文件的异步加载，避免网页失去响应；并且对于管理模块之间的依赖性提供了便利，且便于代码的编写和维护。具体的写法学习，大家可以[参考这里~](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)

以上就是我重温javascript中script标签时的一点思考，算是自己又一次知识的沉淀，也算是将知识的一个综合吧~


- 


- 

