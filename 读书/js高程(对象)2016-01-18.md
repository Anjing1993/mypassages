说起面向对象，就想到了它的一个标志，就是“类”，通过类可以创建任意多个具有相同属性和方法的对象，但是在js中没有类，我们该怎么去处理呢？这时构造函数和对象字面量就该出场啦！
## 创建对象 ##
> 构造函数

而什么是构造函数呢？我以前也一直在纠结，其实​构造函数本身也是函数，只不过可以用来创建对象，也就是说凡是可以通过new操作符来调用的都是构造函数，它的内部使用了this变量;如图1.1很明显普通函数是不能创建对象的；

![图1.1](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/gouzao1.png)

图1.1

而在使用操作符new调用构造函数的时候，​内部其实首先要创建一个对象P1；再将构造函数Person的作用域赋给这个新对象P1，这是this就指向了P1；然后将构造函数中的属性添加到新对象P1上；最后返回新对象，才有了我们可以使用的完整的P1；需要注意的是每个实例化的对象都会有一个constructor属性指向他的构造函数：
  
    console.log(P1.constructor==Person)   //true  
这下就大功告成了吗？no!构造函数并没有想象的那么完美，如图1.2 ​,P1与P2都有eat（）方法，但是这都是在自己的实例上创建的，会有自己的this，所以这里的才会出现false;这个函数的任务是相同的，为什么还要每次都去创建呢？那我们直接将这个函数弄成全局的，每次调用就好了，可是若果有好多这样的函数，那这么多的全局变量，真的会让人想死的！！！再想想，我们能不能将它定成死的，每次引用呢？那这样就引出了下一个方法原型模式

![图1.2](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/gouzao2.png)
图1.2

> 原型模式

- 简单原型
  - 我们知道我们创建的每个函数都会有一个prototype属性，这个属性是一个指针，指向它的原型对象，而这个对象上包含了所有实例可以共享的属性和方法，那我们是不是可以直接将那个函数定义在函数的原型里呢？恭喜你，没有被我带到沟里，是的，就是这样！如图2.1,P1和P2访问的就是同一个函数，我们再也不用担心函数函数重复创建而占用内存呢！ 
  
![](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/yuanxing1.png)图2.1

这里说到了原型对象，你理解原型对象吗？如果不理解的话请猛戳原型对象

又回到刚才，我们使用这种独立构造函数，独立原型的方法在人眼里可能看着会有点奇怪，能不能将它合成一个函数呢？哈哈，不要困惑，不要迷茫，这当然是可以的，就是它：动态原型模式，这也是如今很推荐的一种写法

- 动态原型
  - 它将所有信息都封装在了一个构造函数中，而通过在构造函数中通过检查某个应该存在的方法是否有效，来决定是否要初始化原型，如图2.2中if这段代码在初次调用构造函数时就会执行，而且if里面判断的是初始化之后应该存在的任何属性或方法，不用用一大堆if去检查每个属性或者方法，检查一个即可；我记得还有寄生构造函数模式与稳妥构造函数模式，如果大家 想了解可以查看《js高级程序设计第三版》p160；
  
  ![图2.2](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/yuanxing2.png)图2.2


----------
总的来说，js中创建对象的方法就是这些，至于用哪个，这就根据你的需求来决定了，有了对象，我接下来该干什么呢？哈哈！掐指一算，我觉得你已经猜到了，对！就是继承！！！请继续往下浏览就好！

----------
## 继承 ##
在js中要实现继承的方式好几种，首先让我来讲一下原型链的继承，首先我们得知道什么是原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针，让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型也包含着一个指向另一个构造函数的指针，就这样层层递进，就构成了实例与原型的链条；简洁一点就是：每个对象都有自己的原型，它可以为对象或者null，若是对象，那这个对象也有自己的原型，这样以此类推，就构成了一个链条； 

> 原型链继承

  -  如下图，SubType的原型指向了SuperType的实例化,继承了SuperType，也就是说SuperType中所有的属性和方法现在也存在于SubType.prototype中，这里又为SubType创建了一个实例instance，它不但拥有了SuperType的全部属性和方法，还指向SubType的原型，而SubType指向了SuperType的原型；这里是对原型对象进行了重写，故instance.constructor现在指向的是SuperType 
  
  ![原型链继承](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/yuanxingjicheng1.png)

**注意：**

    a.​所有引用类型默认都继承了object，而这个继承也是通过原型链实现的，即默认原型都会有一个内部指针，指向object.prototype；也就是说上面的SuperType继承了object

    b.​子类覆盖超类方法或者添加超类中不存在的方法，一定要在替换原型语句之后，因为重写时会屏蔽原来的方法

    c.通过原型链继承时，不要使用字面量创建原型方法，这样会重写原型链，会切断原实例化对象与现有原型的联系

    d.包含引用类型的值时，修改一个实例对象上的这个属性值，其他实例对象上的也会改变，所以借用构造函数来解决这个问题
> 借用构造函数
​

它的意思就是通过一定的手段将父对象的构造函数绑定在字对象上，但是这里说的一定手段是什么呢？其实就是apply或者call，使用这种方法的话，所有的方法都是在构造函数中定义的，那就谈不上函数复用了，所以就出现了一种组合继承的方法。如下图：

![构造函数继承](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/gouzaojicheng.png)

> 组合继承

就是将原型链继承和构造函数继承组合在一起，如下图：

![](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/zuhejicheng1.png)
![](https://raw.githubusercontent.com/Anjing1993/mypassages/master/images/zuhejicheng2.png)

其实目前，这种继承还是用的最多的

> 原型式继承

​它这个是在函数内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时对象的构造函数


> 浅复制
 
将父对象的所有属性拷贝给子对象，若父对象是一个数组或者对象，那子对象获得的只是一个内存地址，不但不会真正拷贝，还会篡改父对象

> 深复制

包括对数组和对象的赋值，其实就是在浅复制里做个判断


  