今天是实习的第二天了，昨天办理了入职，今天就开始接触一些规范性的东西，刚好看到了css规范中的性能消耗问题，于是就来挑些**典型**的记录一下了~~~

## filter ##
我想大家对这个属性还是蛮熟悉的，一般我们实现一个透明度都会去使用它，但是这个东西却不是很推荐的，为什么呢？
  
 - 其实ie6是不支持这个属性的，这也是众所周知的 ，为了兼容性我们需要这样写：
 
		.transparent_class {   
		      filter:alpha(opacity=50);   
		      -moz-opacity:0.5;   
		      -khtml-opacity: 0.5;   
		      opacity: 0.5;   
		}
 - 然后就是一个很重要的原因：浏览器在下载 filter 里面的图片时会“冻结”浏览器，停止渲染页面。同时 filter 也会增大内存消耗。最不能忍受的是 filter 样式在每个页面元素（使用到该 filter 样式）渲染时都会被浏览器分析一次，而不是像一般的背景图片渲染模式：使用过该背景图片的所有元素都是被浏览器一次性渲染的。

## Expressions ##
iE5及其以后版本支持在CSS中使用expression，用来把CSS属性和Javascript表达式关联起来，这里的CSS属性可以是元素固有的属性，也可以是自定义属性。就是说CSS属性后面可以是一段Javascript表达式，CSS属性的值等于Javascript表达式计算的结果。 在表达式中可以直接引用元素自身的属性和方法，也可以使用其他浏览器对象。这个表达式就好像是在这个元素的一个成员函数中一样。

	#container { width: expression((documentElement.clientWidth < 725) ? "725px" : "auto" ); 
    //这里的盒子宽度是会依据视口宽度的大小而改变的
虽然它很强大，但是还是不被推荐，这是为什么呢？

- Expression 只有 IE 支持，而且他的执行比大多数人想象的要频繁的多。不仅页面渲染和改变大小 (resize) 时会执行，页面滚动 (scroll) 时也会执行，甚至连鼠标在页面上滑动时都会执行。在 expression 里面加上一个计数器就会知道，expression 的执行上相当频繁的。鼠标的滚动很容易就会使 expression 的执行次数超过 10000。
- css表达式这种在表现(css)中插入行为(js)代码，有悖于web标准的结构、表现、行为相分离的理念。 
- css表达式暴露了一个脚本执行的上下文，可能带来脚本注入的隐患。 
　　基于以上原因，微软最终从IE8 beta2(标准模式下)开始放弃对css表达式的支持

## 值缩写 ##
在编写css的时候，我们时常会使用省略的方式，比如`padding:2px;margin:0 auto;`等等，这些都是司空见惯的，但是作为一个码龙我们都知道，代码能省则省，不能省时坚决不省：
    
    margin:20px 0;
    //这时候，盒子的上下都是20px，左右都是0，但是实质上我们没有必要对下面也设置间距，我们可能更想下面刚好切合，如果这样设置，那每个项都会被重新设置

## CSS 选择器 ##
浏览器是“从右往左”来分析 class 的，它的匹配规则是从右向左来进行匹配的，因此最右边的选择符就是关键选择符。
