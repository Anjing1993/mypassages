
### 浏览器指纹：

**What？**

说到浏览器指纹，我就会想到我们人类的指纹，我们的指纹是一个很特殊的东西：

- **独特性**：对我们来说是一种独特的标识，每个人的指纹都是独特的
- **稳定性**：它不会随着我们的年龄或者发育而发生改变
- **信息量大**： 举个例子：假如你想在一个男女比例差不多的学校找一个人，如果你知道他的性别，那么你可以排除1/2的人，但还是比较难定位的；反之，若你不知道他的性别而知道他的生日，那么你就可以排除1/365的人，这样就会比较好定位，为什么呢？就是因为“生日”比“性别”更加独特，所以它提供的信息量更大。因此我们很容易发现，某个特征越独特，它包含的信息量就越大，即信息量越大的特征就可以把对象定位到越小的范围。这也就是为什么，警察总是通过指纹来猜测作案人员

那么浏览器指纹就比较好理解了，它也是作为浏览器的一种标识，具有独特性，稳定性，信息量大的特点，便于我们在不通过cookie存储就可以识别浏览器，并运用于网络上精确定位到每一个个体去收集数据；当我们使用浏览器访问某个网站时，一般都是基于HTTP协议去访问这个网站的，浏览器就会传输与http协议相关的信息给这个网站，这时候，web网站的服务器必定就可以获取到与我们浏览器相关的指纹信息，具体包含的东西还是挺多的：


 - **user Agent**：用户代理，User-Agent就是客户端浏览器等应用程序使用的一种特殊的网络协议，在每次浏览器（邮件客户端/搜索引擎蜘蛛）进行 HTTP 请求时发送到服务器，服务器就知道了用户是使用什么浏览器（邮件客户端/搜索引擎蜘蛛）来访问的。既然是人为规定的协议，那么就是说不管什么浏览器，默认的UA都是可以更改的。有时候为了达到一些不可告人的目的，我就经常需要更改一下UA的设置，比如伪装一下浏览器类型，比如把浏览器伪装成手机上网。
 - **屏幕分辨率**：屏幕尺寸，颜色深度（16位色或24位色或32位色）
 - **时区**：
 - **浏览器插件信息**：也就是浏览器我们的浏览器安装了那些插件（注意插件和扩展不同，插件往往是可执行的独立程序，可以调用操作系统的api；其扩展名为.exe，如flash插件，网银插件等，而“扩展”的扩展名一般都是.xpi，用于扩展浏览器自身的功能，调用浏览器自身的api）
      - 从形式上讲：插件是已经将代码编译成了机器指令的二进制文件，而扩展是一个源码包。
      - 从作用上讲：插件是为了让firefox能够显示特殊格式的文件而由相应的第三方应用程序（如 windows media player 和 Adobe reader）提供的；而扩展是为了修改或增强firefox本身的功能而由扩展开发者提供的。
      - 从字面意思上讲：插件（plug-ins）的plug是插的意思，一个由外至内的动作；扩展（extensions）的extension是延伸、扩充的意思，一个由内而外的动作。
      - 也就是说：插件是“外部”的，而扩展是“内部”的。
 
 - **浏览器字体信息**： 和浏览器相关的一些字体信息。
 - **HTTP ACCEPT**：是 HTTP 协议头中的一个字段，表示客户端能够接收的内容类型，如text/plain，text/html

**Do ?**

有了浏览器指纹，我们对浏览器指纹的识别就可以创造一种比较新的追踪技术；一般情况下，许多网站都会想要一种技术方式可以精确的定位到每一个个体，这样就可以收集这些个体的数据，然后通过分析就会更加精确的去推送一些广告或者其他一些活动，而增加自己网站的收益。其中，cookie就是一种非常受欢迎的技术，当用户访问一个网站时：网站可以在用户当前的浏览器Cookie中永久植入一个含有唯一标示符（UUID）的信息，并通过这个信息将用户所有行为（浏览了哪些页面？搜索了哪些关键字？对什么感兴趣？点了哪些按钮？用了哪些功能？看了哪些商品？把哪些放入了购物车等等）关联起来。

	 function rand(len) {
	    var hex = "0123456789abcdef",
	        str = "",
	        index = 0;
	    for (len = len || 32; len > index; index++) {
	        str += hex.charAt(Math.ceil(1e8 * Math.random()) % hex.length);
	    }
	    return str;
	}
	
	var uuid = (new Date).getTime() + "_" + rand();
	
	// 写持久化cookie，两年后过期
	// setcookie('uuid', uuid, 732 * 24 * 60 * 60);
之后就可以使用UUID来实现用户追踪技术，方便后续的数据分析工作

慢慢的，网名对自己的隐私越来越看重，于是cookie就不再那么受欢迎，不少安全工具甚至是浏览器都开始允许或引导用户关闭Cookie功能，比如很多主流浏览器都有一个“隐私模式浏览”功能。这样以来，网站就很难追踪用户行为了，这时候“浏览器指纹识别技术”就崛起了：

##### 帆布指纹识别：
它不像通过Cookie或者Flash Cookie等之类的方式，而是使用HTML5专属标签`<canvas>`,在绘制`<canvas>`图片时，同样的`<canvas>`绘制代码，基于Canvas绘制特定内容的图片，使用canvas.toDataURL()方法返回该图片内容的base64编码字符串（这个方法能把画布里的图案转变成base64编码格式的png，然后返回 Data URL数据）。对于PNG文件格式，以块(chunk)划分，最后一块是一段32位的CRC校验，提取这段CRC校验码便可以用于用户的唯一标识

- 原理：
 - 浏览器内核不同，gpu(图像处理引擎)就不同，绘制出来的图片就各不相同并且独一无二的
 - 在像素级别来看，操作系统各自使用了不同的设置和算法来进行抗锯齿和子像素渲染操作
 
- 具体实现：

        //bin2hex() 函数是把ASCII 字符的字符串转换为十六进制值
	    function bin2hex(s) {
	            //  discuss at: http://phpjs.org/functions/bin2hex/
	            // original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	            // bugfixed by: Onno Marsman
	            // bugfixed by: Linuxworld
	            // improved by: ntoniazzi (http://phpjs.org/functions/bin2hex:361#comment_177616)
	            //   example 1: bin2hex('Kev');
	            //   returns 1: '4b6576'
	            //   example 2: bin2hex(String.fromCharCode(0x00));
	            //   returns 2: '00'
	
	            var i, l, o = '',
	                    n;
	
	            s += '';
	
	            for (i = 0, l = s.length; i < l; i++) {
	                n = s.charCodeAt(i)
	                        .toString(16);
	                o += n.length < 2 ? '0' + n : n;
	            }
	
	            return o;
	        }

		
        //一段产生canvas元素的javascript代码：
		var canvas = document.createElement('canvas');
		var ctx = canvas.getContext('2d');
		var txt = 'http://security.tencent.com/';
		ctx.textBaseline = "top";
		ctx.font = "14px 'Arial'";
		ctx.textBaseline = "tencent";
		ctx.fillStyle = "#f60";
		ctx.fillRect(125,1,62,20);
		ctx.fillStyle = "#069";
		ctx.fillText(txt, 2, 15);
		ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
		ctx.fillText(txt, 4, 17);
        //获取绘画的内容，需要使用到canvas.toDataURL()方法，该方法返回的是图片内容的base64编码字符串。对于PNG文件格式，以块(chunk)划分，最后一块是一段32位的CRC校验，提取这段CRC校验码便可以用于用户的唯一标识：
        //.toDataURL()返回 "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACt..."  
		var b64 = canvas.toDataURL().replace("data:image/png;base64,","");//提取CRC校验码
		var bin = atob(b64);  //解码一个已经被base-64编码过的数据
		var crc = bin2hex(bin.slice(-16,-12)); //bin2hex() 函数是把ASCII 字符的字符串转换为十六进制值
		console.log(crc);

- 结果：
 - 同一机器的chrome浏览器，无论正常模式还是隐身模式，得到的crc值始终一致。而对于不同机器得到的值是不同的，追踪效果显而易见

- 测试记录：
 
 - 测试设备： 
     - 3台 Android 2.x
     - 21台 Android 4.x
     - 2台 iOS 6.x
     - 4台 iOS 7.x
     - 1台 iOS 8.x
  - 测试结果：
     - 无论Android还是iOS，只要设备系统相近(同类型系统且版本号接近)的情况下，ID易重复
     。比如Android 4.2.x系统的大量重复：［9c6ad73c－红色色块］、［244ae093－黄色色块］
     -  在Android中，若满足上面的条件，且使用相同浏览器，id更容易重复
           - 比如在Android 4.2.x系统的大量重复的几个ID中：［9c6ad73c－红色色块］在原生浏览器中重复的更严重
,［244ae093－黄色色块］在QQ浏览器中重复的更严重
     - 在iOS系统中，同设备情况下，不管是用什么浏览器，ID都是相同的:测试7台iOS设备都符合这条规则,ID重复率100%
 	 - 在Android系统中，，若任意两台不同设备的原生浏览器生成的ID不同的情况下，它们的UC浏览器和QQ浏览器没发生过重复
	 - 如果浏览器进行了版本升级，ID可能会变也可能不变
- 结论：
 - 优点：
	 - HTML5 canvas技术被所有主流浏览器支持，可以通过大部分的PC、平板、智能手机访问
	 - 它不像通过Cookie或者Flash Cookie等之类的方式，你基本是无法屏蔽它的。
 - 缺陷：
	 - 目前来说canvas指纹很难被阻挡，只要你用浏览器上网，你的行踪就相当于是公开的（ie6可以秒杀这一点）
	     - **需要登录的网站**：
	你可以在网站上注册若干个账号，当你需要切换身份时，只需要先注销用户，清空cookie，然后用另一个账号登录，网站是发现不了的；但是若网站采用了“指纹追踪技术”，你想上面这么做，因为你用的是同一个浏览器，浏览器指纹相同，网站就会知道你是同一个网名
	     - **不需登录的网站**：如果你的浏览器允许记录 cookie，当你第一次访问某网站的时候，网站会在你的浏览器端记录一个 cookie，cookie 中包含某个“唯一性的标识信息”。下次你再去访问该网站，网站服务器先从你的浏览器中读取 cookie 信息，然后就可以根据 cookie 中的“唯一标识”判断出，你之前曾经访问过该网站，并且知道你上次访问该网站时，干了些啥。对付这种 cookie 很简单，你只需要在前后两次访问之间，清空浏览器的 cookie，网站就没法用 cookie 的招数来判断你的身份。
	　　但是“清空 cookie”这招对“浏览器指纹”是无效滴。比如说你的浏览器具有非常独特的指纹，那么当你第一次访问某网站的时候，网站会在服务器端记录下你的浏览器指纹，并且会记录你在该网站的行为；下次你再去访问的时候，网站服务器再次读取浏览器指纹，然后跟之前存储的指纹进行比对，就知道你是否曾经来过，并且知道你上次访问期间干了些啥。
      - canvas指纹ID与设备系统、浏览器相关性非常大。并不是唯一的，会随着浏览器的版本更新发生变化

##### 屏蔽Canvas指纹跟踪：



#####经过优化FingerprintJS：
是一个快速的浏览器指纹库，纯 JavaScript 实现，没有依赖关系。默认情况下，使用 Murmur Hash 算法返回一个32位整数。Hash 函数可以很容易地更换。除了canvas指纹还增加了其他判定因素（fingerprint.js）

- 原理：除了canvas指纹还增加了其他许多判定因素

看源码时发现：

![](https://github.com/Anjing1993/mypassages/blob/master/images/test.png)

- 具体实现：
	
	    <script src="fingerprint.js"></script>
		<script src="canvas.js"></script>
		<script>
		// print fingerprint.js‘s ID
	    var uuid = new Fingerprint({canvas: true}).get();
	    document.write(uuid);

		//如果你想使用屏幕分辨率计算指纹，则需如下调用：
		var fingerprint = new Fingerprint({screen_resolution: true}).get();
		
        //使用自定义的哈希函数
		var my_hasher = new function(value, seed){ return value.length % seed; };
		var fingerprint = new Fingerprint({hasher: my_hasher}).get();
		
        //或者直接传递方法：
		var my_hasher = new function(value, seed){ return value.length % seed; };
		var fingerprint = new Fingerprint(my_hasher).get();

	
	    // print simpleCanvs.js‘s ID
	    document.write('<br\>'+crc);
        </script>
- 因素值：
	- 浏览器http请求中的用户代理－navigator.userAgent
	- 浏览器的语言(中文、英文……)－navigator.language
	- 设备屏幕的色彩信息－screen.colorDepth
	- 设备屏幕的宽高－screen.height screen.width
	- 格林威治时间和本地时间之间的时差－Date().getTimezoneOffset()
	- 是否支持sessionStorage－window.sessionStorage
	- 是否支持localStorage－window.localStorage
	- 是否支持indexdDB－window.indexedDB
	- 是否支持－docment.body.addBehavior(IE5的一个属性)
	- 是否支持调用本地数据库－window.openDatabase
	- 浏览器所在系统的CPU等级－navigator.cupClass
	- 客户端的操作系统－navigator.platform
	- 是否支持Do not track功能－navigator.doNotTrack
	- 获取浏览器部分插件信息－flash plugin、Adobe PDF reader、QuickTime、real players、ShockWave player、Windows media player、Silverlight、Skype
	- canvas指纹
	

- 测试结果：
	      
 - 由于涉及设备以及浏览器的判定因素非常多，重复性很低，31台设备皆无重复
     - 但是可以设想，毕竟是通过各种属性值去判断唯一性，理想情况下如果两台设备相同浏览器各种设置也相同，还是会出现重复
 - 也正因为涉及的因素多，一旦设备系统更新 or 浏览器版本更新 or 浏览器关键插件有变化(版本更新 or 新增卸载关键插件) ，生成的ID都会改变
     - 由于浏览器版本更新还是比较频繁的，很容易失去之前跟踪的用户


- 结论：canvas指纹只能作为一参考属性去判断设备的唯一性，不能只用这一个因素来判定设备唯一性。fingerPrint.js也不能取代cookie，但是可以作为辅助，如果用户清除了cookie的情况下，还可以通过fingerPrint.js跟踪到该用户重新set cookie


[测试数据列表](https://docs.zoho.com/sheet/ropen.do?rid=08m2ga1cf6790c0eb4d8c8f7e54ca6ddb9b72)

##### Panopticlick：
##### Evercookie：[http://www.ituring.com.cn/article/35102](http://www.ituring.com.cn/article/35102)
##### 不用Cookie的“Cookie”技术：[http://blog.jobbole.com/46266/](http://blog.jobbole.com/46266/)